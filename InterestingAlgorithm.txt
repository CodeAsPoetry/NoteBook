第1章：算法之美

1. 考查算法的最坏情况对衡量算法的好坏具有实际的意义。

2. 算法运行需要时需要的辅助空间是衡量空间复杂度的关键因素。

3. 递归调用，包括递推和回归。递推是将原问题不断分解成子问题，直到达到结束条件，返回最近子问题的解；然后逆向逐一回归，最终到达递推开始的原问题，返回原问题的解。

4. O(2^n)<O(n!)<O(n^n)

5. 特征方程和通项公式的推导：详见个人博客https://codeaspoetry.github.io/

6. 斐波那契数列时间复杂度/空间复杂度：O(常数^n)/O(1)，O(n)/O(n)，O(n)/O(1)，（待考查）O(log n)/未知。

7. 心得：真的被斐波那契数列的美震撼了，瞬间想买《数学之美》看看。。。。。。。。。。。。。。。。。。。。。。。。。。

6. 取模：求商时向负无穷方向舍入；取余：求商时向0方向舍入 -7对4取余为-3；-7对4取模为+1

7. 哥德巴赫猜想：任一大于2的偶数，都可表示成两个素数之和


第二章：贪心算法

1. 一个贪心算法总是做出当前最好的选择，也就是说，它期望通过局部最优选择从而得到全局最优的解决方案。————《算法导论》

2. 利用贪心算法求解的问题往往具有两个重要的特性：贪心选择性质和最优子结构性质。

3. 选择排序、冒泡排序使用了贪心算法。

4. 物品可分割的装载问题称为背包问题，物品不可分割的装载问题称为0-1背包问题。

5. 加勒比海盗(选择最轻的)、阿里巴巴与四十大盗(可以分割，选择性价比最高的)、会议安排(选择具有最早结束时间且与已安排的会议相容的会议安排)、最短路径

6. Edsger Wybe Dijkstra和Donald Ervin Knuth并称为我们这个时代最伟大的计算机科学家。

7. Dijkstra算法：解决单源最短路径问题的贪心算法。(这是我见到的最透彻的讲解)

8. 寻常的Dijkstra算法时间复杂度O(n^2),空间复杂度O(n)；经优先队列优化，且换用邻接表存储，时间复杂度可将为O(E*log n)，如果用斐波那契堆，松弛操作的时间复杂度O(1)，总的时间复杂度为O(n*log n + E)。(再次被斐波那契惊呆了，有木有？)

9. 优先队列具有最高级先出的行为特征。

10. 如果每个字符的使用频率相等，固定长度编码是空间效率最高的方法。

11. 哈夫曼算法采取的贪心策略是每次从树的集合中取出没有双亲且权值最小的两棵树作为左右子树

12. 最小生成树：对于n个顶点的连通图，只需n-1条边就可以使这个图连通，n-1条边要想保证图连通，就必须不含回路，所以我们只需要找出n-1条权值最小且无回路的边即可。

13. 避圈法，在一个图中深度搜索或广度搜索有没有回路。在生成树的过程中，把已经在生成树中的结点看作一个集合，把剩下的结点看作另一个集合，从连接两个集合的边中选择一条权值最小的边即可。这就是Prim算法：1957年由美国计算机科学家Robert C.Prim发现。

14. Kruskal算法：将所有边按照权值从小到大排序，选取权值最小的边，不产生回路，加入最小生成树的边集合T中；否则，选取下一条最短边。采用集合避圈：如果所选择加入的边的起点和终点都在T集合中，那么就可以断定一定会形成回路(圈)。合并集合的时间复杂度是O(n^2)，用并查集的思想优化，可降为O(e*log n)。

15. 并查集：两个元素集合号不同，合并时，擒贼先擒王，只改祖宗即可，并不需要把集合中所有结点都检索一遍并修改。

16. 

